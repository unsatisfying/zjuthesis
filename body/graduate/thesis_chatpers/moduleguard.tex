\chapter{针对软件应用层的模块冲突威胁分析与防护框架}
\section{引言}
随着开源软件生态逐渐扩张，AI系统以及其相关的各类辅助软件对第三方库（Third-party Libraries, TPLs）的依赖程度也日益加深，软件供应链的威胁已成为AI软件应用层的核心安全问题之一。由于现代软件开发模式往往高度依赖于第三方组件，这些第三方组件通过高管理工具实现AI软件的环境部署和依赖自动化解析，这不仅意味着开发者往往在无条件的信任第三方组件，在引入第三方组件时形成的庞大复杂的依赖树也加剧了软件层的安全问题分析难度，此时软件应用不仅面临传统意义上的依赖传播和漏洞传播的威胁，更因为编程语言差异和包管理机制的细节差异，衍生出了一系列隐蔽且破坏力极强的新型安全风险。

在所有编程语言中，Python语言凭借其代码简洁性，易读性以及其强大的生态系统PyPI，已经成为AI软件开发领域和数据科学领域的首选编程语言。而随着软件供应链技术的快速发展，开源的第三方库的数量呈现出了爆炸增长的态势。根据Sonatype2026报告显示，仅仅Python生态，在2025年一整年中，组件数量增加了21.48万，版本数量增加了154万，相较于整个生态的82.13万个组件和885万个版本，新增组件数占据了26\%，新增版本数占据了17\%~\cite{sonatype2026software}。然而，随着软件规模的扩大和依赖关系的日益复杂，命名空间冲突的问题也日益显现，且成为了阻碍生态系统健康发展的重要因素。

不同语言针对命名空间冲突问题的处理机制各不相同，但是它们的目标都是“隔离和唯一性”。Java生态采用（groupId, artifactId, version）形式的三元组来唯一区别一个软件包名，并且在安装TPLs时，会将不同的软件包安装在以\code{groupId/artifactId/version}打头的路径中，例如软件包log4j的2.17.0版本下载到本地时会被安装在一个相对路径\code{org/apache/logging/log4j/2.17.0/}下，所以，只要软件包不同，其生态中使用模块便不会冲突。因此Java生态几乎没有命名空间冲突的问题。相比之下，Rust生态采用源码共享，编译期隔离策略，它将所有下载软件包默认安装到\code{~/.cargo/registry/cache/}目录下，然后将这些软件包解压后的源码放置在\code{~/.cargo/registry/src/}目录下，使所有Rust项目共享这些源码。在项目编译期间，cargo会将不同软件包的源码编译到不同的二进制中，并放置在项目的路径中，例如项目中依赖了软件包rand的0.8版本，使用cargo build命令会使项目\code{target/debug/deps}路径中产生名为\code{rand-ba1d2ca50538ba79.d}的二进制文件，并被链接到项目中使用。由此，Rust生态也几乎不会存在命名空间冲突的问题。

然而，Python生态虽然软件包名是唯一索引，然而其模块名却不是唯一，这样的管理机制存在很严重的命名空间冲突问题。首先，Python生态的第三方软件包默认是以平铺的方式放置在同一个\code{site-packages}目录下，例如安装requests和urllib3两个软件包时，pip会从PyPI上下载这个两个软件包的whl分发版本，并分别解压到\code{site-packages}目录下，可是当两个TPLs存在两个同名模块时，例如软件包A存在module1.py的顶层模块，软件包B也存在module1.py的顶层模块，这两个软件包被同时安装时，由于系统路径中只允许存在一个module1.py模块，因为必然会有一个软件包的模块将另一个软件包的模块覆盖。其次，Python项目在引入模块时存在一个搜索优先级机制，其优先搜索当前目录，然后搜索Python内置的系统库和动态链接库中的模块，最后搜索第三方模块，假如某个第三方软件包中存在和系统中相同的sys.py模块，则项目在使用import sys语句引入模块时，永远引入的都是系统中的sys模块，而不会引用到第三方软件包的sys模块。

本研究将 Python 生态系统中由于命名空间资源重叠而引发的安全问题正式定义为模块冲突（Module Conflict, MC），并针对 AI 系统软件应用层面临的这一严峻威胁，设计并实现了一套名为 \code{ModuleGuard} 的自动化检测与防护框架。本章节主要涵盖了以下四个维度的创新性工作:

首先，本研究填补了学术界在细粒度命名空间冲突研究上的空白，完成了业界首次针对 MC 问题的大规模实证研究。通过构建基于 \code{GitHub} Issues 与 \code{StackOverflow} 等多源异构数据的分析框架，本研究对 97 个真实案例进行了深度剖析，系统性地总结出模块冲突的三种核心模式（模块对库、模块对三方库、依赖内冲突）以及两类现实威胁（模块覆盖与导入混淆），为后续的大规模生态治理奠定了坚实的理论基石。

其次，在威胁建模层面，本研究深入挖掘了 Python 包管理工具（如 \code{pip}）在依赖解析与安装过程中的安全缺陷，首次定义了一种针对 AI 系统的新型软件供应链攻击向量——“模块替换攻击”。该攻击利用 Python 扁平化的安装目录结构与“首次匹配”的模块导入机制，使攻击者能够通过构造同名模块路径，在依赖安装阶段静默覆盖目标系统的核心组件，或在运行时劫持正常的模块加载流程。本研究详细论证了该攻击破坏 AI 软件完整性、导致环境不可逆损坏以及在大规模依赖树中潜伏的机理。

在技术实现层面，为了解决大规模软件包模块提取中存在的动态性强、开销大等难题，本研究提出了一套新型模块冲突分析技术与防护框架。其中包括一种名为 \code{InstSimulator} 的无安装语义模拟技术，通过静态模拟 \code{setup.py} 等脚本的执行逻辑，实现了对模块路径的高保真提取；以及一种环境感知型依赖解析算法 \code{EnvResolution}，通过引入环境变量约束与优先级策略，有效解决了复杂依赖场景下解析精度低与速度慢的瓶颈。基于上述核心技术实现的 \code{ModuleGuard} 框架在基准测试中达到了 95\% 以上的检测精度。

最后，本本研究利用\code{ModuleGuard}模块冲突分析框架，进行了大规模的生态分析，其包括分析了截至2023年4月的整个PyPI生态中的43万个软件包（包括420万个软件包版本），研究不仅揭示了模块冲突随生态演进呈指数级增长的趋势，还发现了冲突包在命名语义上的相似性规律。此外，本研究针对 GitHub 上3，711个高星的热门 AI 项目（涉及 93,487 个标签）进行了模块冲突检测，结果显示共有 108 个顶级项目受到供应链模块冲突的影响。本研究通过向开发者报告、工单提交及邮件沟通等方式，协助开发者修复了大量潜在风险，其实用性与有效性得到了开源社区的广泛验证与认可\code{ModuleGuard}能够有效检测AI软件应用层的模块冲突，从而防御来自于模块冲突的威胁。
% 本研究将Python中由于命名空间冲突引起的问题称为模块冲突（Module Conflict, MC）问题，并首次对其进行了大规模地研究，并提出了一套检测MC问题的检测框架，名为ModuleGuard，来实现对软件应用层的安全防护。

% 总的来说，本研究实现了以下贡献:
% \begin{itemize}
%     \item \textbf{业界首次针对MC问题的大规模实证研究。}本研究首次系统性地定义了 Python 生态中的模块冲突问题，并构建了基于多源异构数据（GitHub Issues 与 StackOverflow）的实证分析框架。通过对 97 个真实案例的深度剖析，本研究首次提出了模块冲突的三种核心模式（模块对库、模块对三方库、依赖内冲突）以及两类现实威胁（模块覆盖与导入混淆）。该分类体系填补了学术界在细粒度命名空间冲突研究上的空白，为后续的大规模生态治理提供了理论基石。
%     \item \textbf{提出了名为模块替换攻击的针对AI系统软件应用层的新型攻击。}本研究深入挖掘了 Python 包管理工具（如 pip）在依赖解析与安装过程中的安全缺陷，定义了一种新型软件供应链攻击向量——“模块替换攻击”。该攻击利用 Python 扁平化的安装目录结构与“首次匹配”的模块导入机制，攻击者可通过构造同名模块路径，在依赖安装阶段静默覆盖目标系统的核心组件，或在运行时劫持正常的模块加载流程。本研究详细论证了该攻击破坏 AI 软件完整性、导致环境不可逆损坏以及在大规模依赖树中潜伏的机理，为供应链安全防御提供了新的威胁模型。
%     \item \textbf{新型模块冲突问题分析技术和防护框架。}针对大规模 Python 软件包模块提取中存在的动态性强、开销大等难题，本研究提出了一种名为 \code{InstSimulator} 的无安装语义模拟技术。该技术通过静态模拟 \code{setup.py} 等脚本的执行逻辑，在不执行实际安装的情况下实现了对模块路径的高保真提取。在此基础上，本研究进一步提出了环境感知型依赖解析算法 \code{EnvResolution}，通过引入环境变量约束与优先级策略，解决了现有工具在复杂依赖场景下解析精度低、速度慢的瓶颈。基于上述核心技术，本研究实现了自动化检测框架 \code{ModuleGuard}，并在基准测试中达到了 95\% 以上的检测精度。
%     \item \textbf{大规模的生态分析。}本研究利用\code{ModuleGuard}模块冲突分析框架，本研究进行了大规模的生态分析，其包括分析了截至2023年4月的整个PyPI生态中的43万个软件包（包括420万个软件包版本），研究不仅揭示了模块冲突随生态演进呈指数级增长的趋势，还发现了冲突包在命名语义上的相似性规律。此外，本研究针对 GitHub 上3，711个高星的热门 AI 项目（涉及 93,487 个标签）进行了模块冲突检测，结果显示共有 108 个顶级项目受到供应链模块冲突的影响。本研究通过向开发者报告、工单提交及邮件沟通等方式，协助开发者修复了大量潜在风险，其实用性与有效性得到了开源社区的广泛验证与认可\code{ModuleGuard}能够有效检测AI软件应用层的模块冲突，从而防御来自于模块冲突的威胁。
% \end{itemize}

\subsection{背景知识}

\subsubsection{Python 软件包层级}
\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figure/Python软件包层次结构图.png}
    \caption{\label{fig:python_arch_packages}Python软件包层次结构图}
\end{figure}
Python生态存在复杂的软件包层级，本节内容旨在阐明Python生态中相关的专有名词和供应链的具体过程，如图~\ref{fig:python_arch_packages}所示。Python生态使用pip作为其官方的包管理器，来帮助用户自动化下载和构建依赖。当用户下载软件包时，只需声明要下载的软件包名称或者版本，在命令行中键入\code{pip install <软件包>}即可下载对应软件包的最新版本，当然用户也可以通过键入\code{pip install <软件包><限定符><版本号>}来下载特定的软件包版本，其中限定符可以是\code{==, >, <}等。如图例中所示，当用户需要下载特定的\code{beautifulsoup4}软件包时，pip软件会根据\code{beautifulsoup4}这一项目名称到PyPI上寻找项目的所有版本号，在根据对应的限定符和版本号来确定选择具体项目的哪一个版本，图例中由于没有给定限定符，因此默认选择的是\code{beautifulsoup4}的最新版本，即\code{4.9.3}。然后pip会从\code{4.9.3}版本的所有分发包里选择一个分发包，然后下载到用户本地，图例中选择的是\code{whl}版本的分发包，用户下载后将其在本地直接解压到\code{site-packages}文件夹中，形成最终可引入的包和模块。包是一个文件夹名，而模块是一个\code{.py}文件，其中有个特殊的模块为\code{__init__.py}，其模块名不是\code{__init__}，而是其所在的文件夹的文件夹名，如图例中所示的\code{__init__.py}的模块名为\code{bs4}，所以用户最终可以通过\code{import bs4}语句进行引入。

\subsubsection{Python 依赖管理}
\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figure/Python依赖声明方式.png}
    \caption{\label{fig:python_dep_methods}Python软件依赖声明的四种方式}
\end{figure}

Python语言于1991年首次发布依赖，以简洁易读的语法特性和强大的生态库而沿用至今，然而这也使得Python存在极为严重的历史遗留问题，即Python的软件依赖管理较为复杂，可以通过多种方式进行依赖声明，甚至是利用代码执行逻辑进行声明，这也使得传统依赖提取不完全，进而导致依赖图解析准确率低。

具体来说，一个Python项目，往往通过创建虚拟环境的方式在本地隔离不同项目的依赖，避免版本冲突，即用户通过\code{python -m venv <虚拟环境名>}创建本地环境后并激活该环境，即可在其中任意使用\code{pip}工具而不影响到别的项目。随后用户便可以通过如图~\ref{fig:python_dep_methods}所示的四种方式进行依赖声明。第一种是文本声明方式，即用户也可以在本地项目中包含一个文本文件来声明依赖，该文本文件的每一行都表示一个依赖，这种方式最原始也最灵活，可以添加注释，也可以添加github项目或者一个本地路径，用户在安装依赖时只需使用命令\code{pip install -r <文件名>}即可，而文本文件的名字通常是\code{requirements.txt}，当然也可以是其他任意的名字，此外用户还可以通过\code{pip freeze > requirements.txt}命令自动地生成依赖文本文件。

第二种方式是\code{setup.py}的传统打包声明方式，该方式依赖于\code{setuptools}工具。这种方式首先需要用户在Python文件中引入\code{setuptools}模块的\code{setup}函数，并且调用\code{setup}函数来实现，用户可以通过该函数的\code{install_requires}参数进行声明传统依赖，通过\code{extras_require}声明额外依赖（Extra Dependencies）。由于这种方式是Python脚本形式，所以它支持灵活的动态逻辑，这意味这它可以通过字符串构造，正则匹配，读取文件等多种方式构造出一个Python的列表来声明依赖。而用户安装依赖只需通过命令\code{pip install <项目路径>}即可，pip会自动解析该项目路径下的\code{setup.py}文件进行动态运行安装依赖。

第三种方式是\code{setup.cfg}的声明式配置方式，这也是一种静态的配置文件，同样需要\code{setuptools}工具配合。与 \code{setup.py} 不同，\code{setup.cfg} 采用纯文本的键值对格式（INI风格），用户无需编写 Python 代码，而是通过在 \code{[options]} 节中的 \code{install_requires} 字段声明基础依赖，并在 \code{[options.extras_require]} 中声明额外依赖。这种声明式（declarative）的设计避免了任意 Python 代码的执行，从而提升了可读性、可维护性以及可分析性，使得工具链（如 pip、构建系统或安全扫描工具）能够更容易地静态解析依赖关系。

第四种方式是基于\code{pyproject.toml}的现代依赖声明方式，该方式由 PEP 517、PEP 518 以及 PEP 621 等一系列 Python 官方提案所定义，已逐渐成为当前 Python 生态系统中推荐的标准打包与构建机制~\cite{pep517,pep518,pep621}。\code{pyproject.toml} 通过 TOML 格式统一描述项目的构建后端与依赖信息，从而将构建逻辑与 \code{setuptools} 等具体工具解耦。用户可以在 \code{[project]} 节中通过 \code{dependencies} 字段声明基础依赖，并在 \code{[project.optional-dependencies]} 中声明额外依赖（extra dependencies），而无需再编写 \code{setup.py} 或 \code{setup.cfg} 文件。与 \code{setup.py} 的命令式脚本不同，\code{pyproject.toml} 完全采用声明式配置，所有依赖信息均以静态数据形式存在，因此构建工具能够在不执行任意代码的情况下直接解析依赖关系。这种设计显著提升了构建过程的可预测性与安全性，同时也便于自动化工具、依赖分析器以及安全扫描系统对依赖图进行静态分析。得益于上述优势，现代包管理工具（如 pip、Poetry、Hatch 与 PDM）均优先支持或默认使用 \code{pyproject.toml}，使其逐渐取代传统的 \code{setup.py}/\code{setup.cfg} 方案，成为 Python 项目的事实标准配置方式。

\subsection{研究动机与现状}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figure/模块冲突案例.png}
    \caption{\label{fig:MC_example}Python模块冲突真实案例及其影响}
\end{figure}
\subsubsection{研究动机}
模块冲突问题已成为破坏真实世界 AI 软件供应链安全与稳定性的严重威胁。如图~\ref{fig:MC_example} 所示，我们通过两个典型的真实案例来揭示其危害机制。

\textbf{案例一：跨环境模块冲突导致的导入混淆威胁。} 软件包 jwt (v1.3.1) 与 pyjwt (v2.6.0) 均包含完全相同的模块路径 jwt/exceptions.py。在复杂的开发环境中，这两个包可能分别被安装于系统级的 site-packages 目录与用户虚拟环境的 site-packages 目录中。当 AI 软件代码执行 from jwt import exceptions 语句时，Python 解释器遵循 sys.path 的“首次匹配原则”进行模块搜索。系统级路径的优先级往往会高于虚拟环境路径，因此解释器会错误地加载系统目录中的 jwt 包的模块，而非用户预期在虚拟环境中配置的 pyjwt 的模块。这种导入混淆往往导致运行时属性错误或逻辑异常，使得 AI 软件无法正常启动或产生错误结果。

\textbf{案例二：扁平化依赖安装导致的模块覆盖威胁。}
pip 在安装 ysr-monitor (v0.1.5) 软件时会自动解析并安装其依赖树中所有包含的软件包。然而，其传递性依赖图中存在两个相互模块冲突的软件包：board (v1.0) 和 adafruit-blinka (v8.20.1)。这两个包在根目录下均包含名为 board.py 的模块文件。由于 Python 包管理器采用扁平化的安装策略，即默认将所有依赖包解压至同一个 site-packages 目录下且不进行物理隔离，这导致后安装的软件包会直接、静默地覆盖先安装软件包中的同名模块。这种模块覆盖行为不仅破坏了原有软件包的完整性，还导致本地运行环境遭受不可逆的损坏，用户将无法再正常调用被覆盖的模块功能。

\subsubsection{研究现状}
针对Python生态系统的依赖管理与安全问题，现有工作已经在环境推断、依赖修复以及恶意包检测等方面进行了深入研究。然而，针对本章核心关注的模块冲突问题，现有研究仍然没有很好地进行涉猎研究，在生态系统层面的分析上，现有工作在依赖解析技术和分析粒度上仍存在显著的局限性。

\textbf{Python 运行环境推断与修复。} 针对 Python 项目跨环境部署时因依赖缺失或版本不兼容引发的运行故障，学术界提出了一系列自动化推断与恢复技术。Cheng 等人提出的 PyCRE 旨在利用领域知识图谱推断兼容的运行时环境，然而该方法依赖于执行 pip 安装命令动态提取模块信息及依赖关系，这种高开销方式严重限制了其扩展性与成功率（仅覆盖 10,000 个软件包），且其采用的最长前缀匹配策略过于简化，无法有效应对复杂的模块冲突威胁~\cite{cheng2022conflict}。Ye 等人提出的 PyEGo 则基于知识库自动推断 Python 程序的兼容依赖版本，进一步涵盖了解释器版本与系统库约束，但在处理模块冲突时，PyEGo 倾向于利用 Libraries.io 的 SourceRank 指标选择最流行的软件包以缩减搜索空间，这种基于流行度的假设往往导致错误的依赖归因~\cite{ye2022knowledge}。针对特定场景，Wang 等人提出的 SnifferDog 致力于恢复 Jupyter Notebook 的执行环境，但并未考虑模块冲突问题~\cite{wang2021restoring}；而 Garcia 等人开发的 DockerizeMe 能够为 Python 项目自动生成 Docker 镜像文件，但在解决模块归属时同样依赖于软件包流行度指标~\cite{horton2019dockerizeme}。尽管上述工作在环境恢复领域取得了进展，但在应对模块冲突问题上存在根本性局限。这些方法通常基于“模块-包”的一对一静态映射假设，或依赖最长前缀匹配、流行度优先等启发式算法进行简化处理。这种处理方式忽略了多软件包共享同一模块路径的客观事实，导致其难以在复杂软件供应链中检测并修复真实的模块冲突。

\textbf{依赖冲突管理与修复。} 现有依赖管理研究主要集中在依赖冲突分析层面，即不同的软件组件需要同一依赖包的不兼容版本。Wang 等人提出了 Watchman 框架，首次针对依赖冲突问题进行了大规模分析，通过收集的 235 个真实的依赖冲突问题总结了依赖冲突的模式，并对整个生态的软件包进行持续监控预测分析依赖冲突问题，帮助开发者进行修复。随后，pip 工具更新了它的依赖解析算法，采用回溯方法来解决依赖冲突问题~\cite{pip2025dependency}。Wang 等人根据新的依赖解析策略进行实证重访，发现新型算法虽然能解决依赖冲突，但是存在效率低下的问题，为此他们提出了 SmartPip 框架，采用离线依赖知识库和 SMT 约束求解策略求解依赖图，并用软件包缓存和软链接机制解决隔离环境空间浪费问题~\cite{wang2022smartpip}。Li 等人开发了 EasyPip 静态分析工具，将依赖检测和冲突修复转化为图搜索问题，提出了一种基于图搜索和贪婪算法的修复策略，实现了对原始配置文件的最小化修改~\cite{li2023easypip}。此外，Pipreqs 和 PyDFix 等工具旨在生成依赖文件或通过日志分析修复安装失败的问题~\cite{pipreq,mukherjee2021fixing}。然而，上述工作与本研究关注的模块冲突存在本质区别。依赖冲突关注的是版本约束的可满足性，而模块冲突关注的是文件系统层面的命名空间冲突。现有工具通常假设只要安装过程没有报错，环境就是健康的。它们忽略了 Python 包管理器在无隔离机制下，后安装的包可能静默覆盖先安装包的同名模块这一关键威胁。此外，Pipreqs 等工具采用的简单映射机制并无法处理不同包包含相同模块路径的复杂情况。

\textbf{Python 生态系统安全分析。} 在安全领域，现有研究主要聚焦于恶意软件包的检测，涵盖了针对拼写错误抢注、依赖混淆以及恶意代码植入的大规模分析。Alfadel 等人基于 1,396 份漏洞报告，深入刻画了 PyPI 中安全漏洞的生命周期与传播机制，并揭示了漏洞在依赖链中具有较长的潜伏期以及下游项目修复严重滞后的现状~\cite{alfadel2023empirical}。在针对解释型包管理器安全性的系统评估方面，Duan 等人提出了一套比较分析框架，定性分析了 npm、PyPI 和 RubyGems 的安全特性差距。他们结合元数据分析、静态分析和动态分析技术构建了恶意包检测流水线，成功在官方开原仓库中发现了 339 个恶意软件包，揭示了解释型语言生态中供应链攻击的严峻现状~\cite{duan2020towards}。Guo 等人构建了一个包含 4,669 个恶意软件包的多源数据集，对它们进行大规模地实证研究，剖析了恶意代码的生命周期与攻击向量，发现 setup.py 是最主要的恶意代码注入载体，且超过半数的恶意包表现出复合型的恶意行为特征~\cite{guo2023empirical}。Ruohonen 等人对 PyPI 生态中的 19.7 万个软件包进行了大规模实证研究。利用静态分析工具 Bandit，他们发现约 46\% 的软件包包含至少一种安全隐患，其中异常处理缺陷和由 subprocess 模块引发的代码注入风险最为普遍~\cite{ruohonen2021large}。Vu等人研究了 Python 生态系统中的潜在拼写错误等攻击向量，但并未深入探讨由于良性或恶意的模块命名冲突引发的系统性风险~\cite{vu2020typosquatting}。尽管上述工作在恶意包检测和漏洞传播分析方面取得了显著成果，但它们主要聚焦于代码层面的恶意性，例如软件包中存在的后门和挖矿脚本等，并未考虑即便是不包含任何恶意代码的良性包，也可能因模块路径冲突覆盖关键系统组件，导致类似“拒绝服务”或“环境劫持”的严重后果。

综上所述，现有工作主要关注依赖版本的兼容性或安装过程的成功与否修复，对于软件应用层的安全分析也缺乏对安装后模块冲突问题的系统性分析。其技术主要局限性体现在：

\begin{itemize}
\item \textbf{模块信息提取精度低：}大多工作都是直接从软件压缩包中获取模块名，并且采用模块-包的简单一对一映射，忽略了Python包安装过程中复杂的动态行为。
\item \textbf{依赖解析准确率和效率低：}大多工作仅从单一文件源，如 setup.py 或者 requires.txt 提取静态依赖信息，未能识别多个动态脚本依赖情况，导致依赖解析准确率低；部分工作采用 pip 安装的手段进行回溯安装，导致大量软件包下载浪费，存在解析效率低下问题。
\item \textbf{模块冲突分析与防护不全面：}大部分工具都没考虑到模块冲突问题，即使考虑到存在不同软件包有相同模块的情况，也采用的是最长前缀匹配、流行度优先等启发式算法，并未真正地分析和解决模块冲突问题。
\end{itemize}

针对这些不足，本章提出的大规模检测框架 ModuleGuard 旨在填补这一空白，通过精确的无安装模块提取技术和环境感知的依赖解析算法，系统地揭示并防御 AI 系统软件应用层的模块冲突威胁。

\section{ModuleGuard设计概览}
针对 Python 软件供应链中普遍存在的模块冲突威胁，本章提出并实现了一套名为 ModuleGuard 的自动化分析与检测框架。该框架面向 AI 系统软件应用层，旨在实现从模块信息提取、依赖关系解析到冲突检测的全流程自动化防护。本节将首先剖析在生态系统规模下实现上述目标所面临的技术挑战，进而详细阐述 ModuleGuard 应对这些挑战的系统架构与设计细节。
\subsection{面临挑战}
在 Python 生态系统级别实现模块冲突的自动化分析与防护，主要面临以下两个关键技术挑战：

\begin{figure}[t]
    \centering
    \includegraphics[width=0.87\linewidth]{figure/模块安装前后改变.png}
    \caption{\label{fig:module_change_example}模块在安装前后发生改变案例}
\end{figure}
\textbf{异构分发格式带来的模块信息提取复杂性。}
首先，Python 软件包分发格式的高度异构性显著增加了信息提取的难度。受限于 Python 生态的历史演进，同一软件包版本往往存在多种分发格式（如 .egg, .whl, .zip 等源码包或二进制包），且针对不同的操作系统（如 Windows, Linux）及 Python 解释器版本，软件包的构建方式与文件结构亦存在差异。这种文件格式与配置规范的多样性，加之缺乏统一的模块元数据解析标准文档，使得静态解析并提取模块信息极具挑战性。其次，模块信息具有动态性，即在安装过程中可能受到配置文件（如 \code{setup.py}）逻辑的控制而发生结构性变更。如图~\ref{fig:module_change_example} 所示，\code{pugs} 软件包在安装过程中，其模块目录被重命名为 \code{pugs_lib}，而 \code{namespace_pugs/__init__.py} 文件则被移除。这种安装前后的状态不一致性，意味着单纯基于静态文件分析的方法难以获取准确的运行时模块视图。

\textbf{大规模依赖图解析中的效率与准确性权衡难题。}
本研究旨在对包含超过 420 万个软件包版本的整个 PyPI 生态系统进行全量分析，这对依赖解析算法的效率与准确性提出了双重挑战。在准确性方面，现有工作虽尝试利用本地知识库加速和 SMT 约束求解，但其依赖元数据获取方式往往过于片面，通常仅解析单一类型的配置文件（如仅分析源码包中的 \code{setup.py} 或二进制包中的 \code{requires.txt}），导致元数据缺失。此外，Python 依赖关系具有强环境敏感性，现有静态方法常忽略环境标记（Environment Markers）和额外依赖（Extra Dependencies），从而导致解析结果不完整。在效率方面，尽管直接调用 \code{pip} 进行实际安装可获取准确的依赖图，但由于 Python 包管理器采用回溯算法进行依赖版本仲裁，该过程会触发海量软件包的重复下载与安装试错。在生态系统级别的分析任务中，这种基于动态安装的解析方式将产生极其高昂的时间成本与计算开销，不具备可扩展性。

\subsection{具体设计}
\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figure/ModuleGuard框架图.png}
    \caption{\label{fig:module_framework}ModuleGuard框架图}
\end{figure}
为应对前述技术挑战，本章提出并设计了 ModuleGuard 自动化分析与防护框架。如图~\ref{fig:module_framework} 所示，该框架的整体工作流主要由三个核心阶段构成：

第一阶段为元数据采集与解析引擎构建。该阶段旨在全面提取 Python 生态系统中所有可用软件包及其历史版本的元数据。针对异构分发格式导致的模块信息提取难题，本研究创新性地提出了一种基于无安装语义模拟的提取技术 InstSimulator。该技术通过对多源异构元数据进行自动化提取与归一化解析，结合虚拟文件树的状态模拟，实现了对海量软件包安装后真实模块路径的高效、精准推演。同时，为打破大规模依赖解析中效率与准确性的权衡难题，本研究设计了环境感知型依赖解析策略 EnvResolver。该策略通过引入本地环境约束条件显著提升了传递性依赖的解析精度，并结合依赖解析顺序的启发式优化算法大幅降低了回溯开销，从而支撑全生态规模的高效依赖图谱构建。

第二阶段为模块冲突模式的实证溯源与威胁建模。该阶段旨在对模块冲突现象进行细粒度的特征刻画，深入剖析其根本成因与衍生影响。本研究系统性地采集了 GitHub 与 StackOverflow 等开源社区中与模块冲突相关的真实 Issue 与讨论记录~\cite{github-website,stackoverflow-website}。通过多维度的定性分析与归纳，最终提炼出三种典型的模块冲突模式，并严格界定了其在现实世界中可能引发的两类核心安全威胁。

第三阶段为全生态规模的模块冲突检测与安全治理。基于前两阶段构建的解析引擎与威胁模型，本阶段旨在对整个 PyPI 生态仓库及 GitHub 上的热门 AI 项目进行全量的模块冲突自动化扫描。本研究不仅量化评估了模块冲突风险在供应链层面的演进规律，还通过主动向开源社区披露潜在风险并协助开发者修复依赖配置，在 AI 软件应用层构建了一套抵御模块冲突威胁的闭环防御机制。

\subsubsection{InstSimulator 设计}
为了解决异构分发格式的模块信息提取难题，本研究设计并提出了 InstSimulator 技术，该技术核心逻辑是将异构的分发软件包进行静态元数据解析，形成统一的解析参数，并结合文件树的抽象模拟，从而在不实际执行安装逻辑的前提条件下，高效且准确地从异构软件包中提取出模块路径信息。

\textbf{多源元数据提取。} 在处理异构软件包方面，本研究首先对 PyPI 生态中所有与模块相关的配置文件以及他们的格式，参数进行了系统性地研究。如表~\ref{tab:statistic metadata}所示，


\begin{table}[htbp]
\centering
\small
\renewcommand{\arraystretch}{1.5}
\caption{模块路径和依赖声明相关文件和参数列表}
\label{tab:statistic metadata}

\begin{threeparttable}
\begin{tabular}{
    >{\centering\arraybackslash}m{2.4cm}
    >{\raggedright\arraybackslash}m{2.6cm}
    >{\raggedright\arraybackslash}m{5.2cm}
    >{\raggedright\arraybackslash}m{4.8cm}
}
\toprule

% ================= 表头 =================
\cellcolor[HTML]{C0C0C0}\textbf{分类} &
\cellcolor[HTML]{C0C0C0}\textbf{文件 (File)} &
\cellcolor[HTML]{C0C0C0}\textbf{模块相关数据} &
\cellcolor[HTML]{C0C0C0}\textbf{依赖相关数据} \\
\midrule

% ================= 元数据文件 =================
\multirow{3}{*}{\textbf{元数据文件}}
& \cellcolor[HTML]{FFFFFF}EGG-INFO\tnote{*}
& \cellcolor[HTML]{FFFFFF}top\_level.txt, SOURCES.txt
& \cellcolor[HTML]{FFFFFF}requires.txt \\

& \cellcolor[HTML]{EFEFEF}egg-info\tnote{*}
& \cellcolor[HTML]{EFEFEF}top\_level.txt, SOURCES.txt, namespace\_packages.txt
& \cellcolor[HTML]{EFEFEF}requires.txt \\

& \cellcolor[HTML]{FFFFFF}dist-info\tnote{*}
& \cellcolor[HTML]{FFFFFF}top\_level.txt, RECORD, namespace\_packages.txt
& \cellcolor[HTML]{FFFFFF}METADATA \\
\midrule

% ================= 配置文件 =================
\multirow{3}{*}{\textbf{配置文件}}
& \cellcolor[HTML]{EFEFEF}setup.py
& \cellcolor[HTML]{EFEFEF}py\_modules, packages, package\_dir, namespace\_packages
& \cellcolor[HTML]{EFEFEF}install\_requires, extras\_require \\

& \cellcolor[HTML]{FFFFFF}setup.cfg
& \cellcolor[HTML]{FFFFFF}py\_modules, packages, package\_dir, namespace\_packages
& \cellcolor[HTML]{FFFFFF}install\_requires, extras\_require \\

& \cellcolor[HTML]{EFEFEF}pyproject.toml
& \cellcolor[HTML]{EFEFEF}py-modules, packages, package-dir
& \cellcolor[HTML]{EFEFEF}dependencies, optional-dependencies \\

\bottomrule
\end{tabular}

\begin{tablenotes}
\footnotesize
\item[*] 大写的 EGG-INFO 是 ``egg'' 类型包的元数据；小写 egg-info 是 ``tar.gz'' 源码包元数据；dist-info 则是 ``whl'' 包元数据。
\end{tablenotes}

\end{threeparttable}
\end{table}



\section{ModuleGuard具体实现}

\section{实验与评估}

\section{本章小节}