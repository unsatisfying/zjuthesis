\chapter{AI 系统供应链背景知识}

随着 AI 技术的大力发展，其被应用在现代社会的多个关键领域，并成为当前时代下的核心生产力。在这一过程中， AI 系统也由原本的单一推理模型，轻量级数据和简单应用交互的特点演进为由软件应用、模型框架、硬件加速平台等多层组件共同构成的复杂系统。在这一结构下，AI 系统的开发、训练、部署与运行高度依赖第三方代码库、预训练模型、运行时框架以及异构硬件与驱动程序，逐步形成了一条跨越多个技术层级与信任边界的 AI 系统供应链。相比于传统软件供应链，AI 系统的供应链结构更加复杂，也引入了大量的新型攻击面。本章首先对 AI 系统供应链的整体架构进行梳理，从软件应用层、模型框架层以及硬件加速层三个关键层级出发，介绍各个层级的供应链基本组成，功能职责以及所面临的威胁，从而为后续章节针对不同层级展开的安全分析与攻击奠定背景基础。

\section{软件应用层供应链}
在 AI 软件开发过程中，为了显著降低研发成本并加速功能迭代，开发者通常遵循“避免重复造轮子”的工程实践，广泛复用已有的开源代码、第三方组件以及成熟的软件开发工具链。与传统软件相比，AI 软件在数据处理、数值计算与模型推理等方面对功能组件的依赖更为密集，这使得其软件应用层天然构建在一条高度依赖外部资源的供应链之上。

总体而言，AI 系统的软件应用层供应链主要由两条相互交织的子链路构成：一方面是开源组件自身的开发、演化与分发过程；另一方面是AI 软件在开发、构建与维护过程中对外部代码或组件的引入和复用过程。如图~\ref{fig:AI_software_development} 所示，这两条链路共同构成了 AI 软件应用层的基础生态，并在实际工程实践中紧密联系。

\textbf{开源组件开发过程链路。}
在组件开发阶段，组件开发者通常围绕通用功能或特定需求实现可复用的软件模块，并将其发布至公共的开源组件库中，供其他开发者下载与使用。与此同时，组件开发者自身也往往依赖已有的第三方组件，通过直接引入、二次封装或定制化修改的方式完成新组件的开发。因此，组件开发过程本身同样嵌套在更上游的组件供应链之中。
不同编程语言通常对应不同的组件分发生态。例如，Python 语言主要依赖 PyPI，Java 语言对应 Maven Central，Rust 语言则以 Crates.io 作为官方组件仓库~\cite{pypi-website,maven-central,crates-io}。这些集中式组件库极大地降低了依赖获取与分发成本，使得复杂 AI 功能可以通过少量依赖声明快速集成。然而，与之相伴的是依赖规模和复杂度的持续增长。
对于 C/C++ 等底层语言而言，由于其发展历史较早、应用场景高度多样，整体生态呈现去中心化特征，缺乏统一的官方组件仓库。这类语言通常依赖系统原生库（如 GNU C Library）或厂商提供的专有库（如 NVIDIA CUDA-X 库）~\cite{glibc-website,nvidia-cuda-x-libraries}。近年来，尽管出现了诸如 Conan 等第三方包管理工具，但其应用范围与生态成熟度仍相对有限~\cite{sarkar2025cophi}。这种多样化的分发模式进一步增加了 AI 软件应用层供应链的异构性。

\textbf{AI 软件的开发过程链路。}
在 AI 软件的实际开发过程中，软件开发者通常借助源代码管理工具对项目进行协作开发与持续维护。除通过包管理器引入第三方开源组件外，开发者还可能直接采用源码克隆、代码片段复用等方式，将外部项目中的实现集成至自身代码库中，从而进一步缩短开发周期。这一过程中，版本控制系统与代码托管平台成为软件应用层供应链的关键基础设施。当前，Git 已成为事实上的标准版本控制工具，而 GitHub、GitLab、Gitee 以及企业内部代码托管平台则承担了代码协作、审计与发布的重要角色。在软件开发完成后，构建与打包工具被用于生成可部署的软件形态，例如可执行二进制文件、安装包或容器镜像，并最终交付给终端用户。

\begin{figure}[t]
    \centering
    \includegraphics[width=0.85\linewidth]{figure/AI软件开发.png}
    \caption{\label{fig:AI_software_development}软件应用层供应链架构图}
\end{figure}

\textbf{依赖解析的复杂性和动态性。}
在上述两条供应链链路的共同作用下，AI 软件应用层逐步形成了结构复杂、层级深度较大的依赖关系网络，通常以依赖图的形式进行刻画。如图~\ref{fig:albumentationsx_dependency_graph} 所示，albumentationsx 软件在 2.0.13 版本中依赖多个第三方组件，并进一步引入多层间接依赖~\cite{albumentationsx-repo}。
%
在一个依赖图中，单个软件包通常对应一个特定版本，但在某些语言生态（如 JavaScript）中，同一依赖图中可能同时存在同一组件的多个版本。每一个软件包既可能作为直接依赖被上层软件显式引入，也可能作为间接依赖隐藏在更深层的依赖链路中。例如，图中 numpy 2.2.6 版本既是 albumentationsx 的直接依赖，同时也是其经由 scipy 1.16.3 引入的间接依赖。
%
此外，AI 软件的依赖图并非静态不变。依赖版本往往通过范围约束进行声明，例如在 albumentationsx 的配置文件 setup.py 中指定的一条依赖为 numpy>=1.24.4~\cite{albumentationsx-setup}。在此情况下，依赖解析工具通常会选择满足约束条件的最新版本。一旦上游组件发布新版本，软件在重新构建或安装时，其依赖图结构便可能随之发生变化，从而引入新的行为差异。

依赖图的动态性也使得依赖解析算法变得极其复杂。以 Python 生态为例，用户通常通过官方包管理器 pip 安装第三方依赖组件~\cite{pip-documentation}。在安装过程中，pip 会解析配置文件中的依赖声明，并从 PyPI 获取候选版本列表，依据版本约束与兼容规则逐步选择合适的版本进行下载与安装。该解析过程会递归地处理新引入的依赖，并在出现冲突时进行回溯与重新选择。
由于该过程采用边解析边安装的策略，依赖规模较大时往往面临解析效率低下、冲突频繁等问题，甚至可能因为依赖地狱或者依赖冲突问题导致整个依赖解析过程失败~\cite{wang2022smartpip,fan2020escaping}。这种高度动态且依赖密集的安装机制，使得 AI 软件应用层在功能灵活性提升的同时，也不可避免地引入了更复杂的且难以全面发现的供应链安全风险。

\begin{figure}[t]
    \centering
    \includegraphics[width=0.85\linewidth]{figure/依赖图.png}
    \caption{\label{fig:albumentationsx_dependency_graph} albumentationsx 软件 2.0.13版本依赖图}
\end{figure}

\textbf{软件应用层供应链对AI系统的威胁。}

