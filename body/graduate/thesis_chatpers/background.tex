\chapter{AI 系统供应链背景知识}

随着 AI 技术的大力发展，其被应用在现代社会的多个关键领域，并成为当前时代下的核心生产力。在这一过程中， AI 系统也由原本的单一推理模型，轻量级数据和简单应用交互的特点演进为由软件应用、模型框架、硬件加速平台等多层组件共同构成的复杂系统。在这一结构下，AI 系统的开发、训练、部署与运行高度依赖第三方代码库、预训练模型、运行时框架以及异构硬件与驱动程序，逐步形成了一条跨越多个技术层级与信任边界的 AI 系统供应链。相比于传统软件供应链，AI 系统的供应链结构更加复杂，也引入了大量的新型攻击面。本章首先对 AI 系统供应链的整体架构进行梳理，从软件应用层、模型框架层以及硬件加速层三个关键层级出发，介绍各个层级的供应链基本组成，功能职责以及所面临的威胁，从而为后续章节针对不同层级展开的安全分析与攻击奠定背景基础。

\section{软件应用层背景知识}
在 AI 软件开发过程中，为了显著降低研发成本并加速功能迭代，开发者通常遵循“避免重复造轮子”的工程实践，广泛复用已有的开源代码、第三方组件以及成熟的软件开发工具链。与传统软件相比，AI 软件在数据处理、数值计算与模型推理等方面对功能组件的依赖更为密集，这使得其软件应用层天然构建在一条高度依赖外部资源的供应链之上。

\subsection{软件供应链复杂性}
总体而言，AI 系统的软件应用层供应链主要由两条相互交织的子链路构成：一方面是开源组件自身的开发、演化与分发过程；另一方面是AI 软件在开发、构建与维护过程中对外部代码或组件的引入和复用过程。如图~\ref{fig:AI_software_development} 所示，这两条链路共同构成了 AI 软件应用层的基础生态，并在实际工程实践中紧密联系。

\textbf{开源组件开发过程链路。}
在组件开发阶段，组件开发者通常围绕通用功能或特定需求实现可复用的软件模块，并将其发布至公共的开源组件库中，供其他开发者下载与使用。与此同时，组件开发者自身也往往依赖已有的第三方组件，通过直接引入、二次封装或定制化修改的方式完成新组件的开发。因此，组件开发过程本身同样嵌套在更上游的组件供应链之中。
不同编程语言通常对应不同的组件分发生态。例如，Python 语言主要依赖 PyPI，Java 语言对应 Maven Central，Rust 语言则以 Crates.io 作为官方组件仓库~\cite{pypi-website,maven-central,crates-io}。这些集中式组件库极大地降低了依赖获取与分发成本，使得复杂 AI 功能可以通过少量依赖声明快速集成。然而，与之相伴的是依赖规模和复杂度的持续增长。
对于 C/C++ 等底层语言而言，由于其发展历史较早、应用场景高度多样，整体生态呈现去中心化特征，缺乏统一的官方组件仓库。这类语言通常依赖系统原生库（如 GNU C Library）或厂商提供的专有库（如 NVIDIA CUDA-X 库）~\cite{glibc-website,nvidia-cuda-x-libraries}。近年来，尽管出现了诸如 Conan 等第三方包管理工具，但其应用范围与生态成熟度仍相对有限~\cite{sarkar2025cophi}。这种多样化的分发模式进一步增加了 AI 软件应用层供应链的异构性。

\textbf{AI 软件的开发过程链路。}
在 AI 软件的实际开发过程中，软件开发者通常借助源代码管理工具对项目进行协作开发与持续维护。除通过包管理器引入第三方开源组件外，开发者还可能直接采用源码克隆、代码片段复用等方式，将外部项目中的实现集成至自身代码库中，从而进一步缩短开发周期。这一过程中，版本控制系统与代码托管平台成为软件应用层供应链的关键基础设施。当前，Git 已成为事实上的标准版本控制工具，而 GitHub、GitLab、Gitee 以及企业内部代码托管平台则承担了代码协作、审计与发布的重要角色。在软件开发完成后，构建与打包工具被用于生成可部署的软件形态，例如可执行二进制文件、安装包或容器镜像，并最终交付给终端用户。

\begin{figure}[t]
    \centering
    \includegraphics[width=0.85\linewidth]{figure/AI软件开发.png}
    \caption{\label{fig:AI_software_development}软件应用层供应链架构图}
\end{figure}

\textbf{依赖解析的复杂性和动态性。}
在上述两条供应链链路的共同作用下，AI 软件应用层逐步形成了结构复杂、层级深度较大的依赖关系网络，通常以依赖图的形式进行刻画。如图~\ref{fig:albumentationsx_dependency_graph} 所示，albumentationsx 软件在 2.0.13 版本中依赖多个第三方组件，并进一步引入多层间接依赖~\cite{albumentationsx-repo}。
%
在一个依赖图中，单个软件包通常对应一个特定版本，但在某些语言生态（如 JavaScript）中，同一依赖图中可能同时存在同一组件的多个版本。每一个软件包既可能作为直接依赖被上层软件显式引入，也可能作为间接依赖隐藏在更深层的依赖链路中。例如，图中 numpy 2.2.6 版本既是 albumentationsx 的直接依赖，同时也是其经由 scipy 1.16.3 引入的间接依赖。
%
此外，AI 软件的依赖图并非静态不变。依赖版本往往通过范围约束进行声明，例如在 albumentationsx 的配置文件 setup.py 中指定的一条依赖为 numpy>=1.24.4~\cite{albumentationsx-setup}。在此情况下，依赖解析工具通常会选择满足约束条件的最新版本。一旦上游组件发布新版本，软件在重新构建或安装时，其依赖图结构便可能随之发生变化，从而引入新的行为差异。

依赖图的动态性也使得依赖解析算法变得极其复杂。以 Python 生态为例，用户通常通过官方包管理器 pip 安装第三方依赖组件~\cite{pip-documentation}。在安装过程中，pip 会解析配置文件中的依赖声明，并从 PyPI 获取候选版本列表，依据版本约束与兼容规则逐步选择合适的版本进行下载与安装。该解析过程会递归地处理新引入的依赖，并在出现冲突时进行回溯与重新选择。
由于该过程采用边解析边安装的策略，依赖规模较大时往往面临解析效率低下、冲突频繁等问题，甚至可能因为依赖地狱或者依赖冲突问题导致整个依赖解析过程失败~\cite{wang2022smartpip,fan2020escaping}。这种高度动态且依赖密集的安装机制，使得 AI 软件应用层在功能灵活性提升的同时，也不可避免地引入了更复杂的且难以全面发现的供应链安全风险。

\begin{figure}[t]
    \centering
    \includegraphics[width=0.85\linewidth]{figure/依赖图.png}
    \caption{\label{fig:albumentationsx_dependency_graph} albumentationsx 软件 2.0.13版本依赖图}
\end{figure}

\subsection{软件供应链对AI系统的威胁与现有防护}
由于软件供应链的无条件信任机制和依赖解析的复杂性和动态性，导致其对 AI 系统软件应用层存在多方面的威胁。主要分为四个大类，代码来源威胁，基础设施威胁，软件运行时威胁和依赖传播威胁。

\textbf{代码来源威胁与防护。}
代码来源威胁主要来自于三个方面：一是组件开发人员或者软件开发人员编写代码时不经意间引入的不安全代码或者漏洞；二是攻击者通过控制开发者账户或者代码篡改权限，对代码仓库进行恶意投毒；三是开发者滥用AI生成的代码引入的安全风险。开发者编写代码时引入漏洞的主要原因是开发者编码时的错误或者疏忽，或者是开发者通过代码克隆将别人包含漏洞的代码无意地拷贝到开发代码中并上线导致的，此类漏洞往往难以发现，并且存在时间较久，例如 CVE-2024-36904 被认为是 Linux 内核中“潜伏时间”非常长的高危漏洞之一，其存在于TCP系统中，并且能够使得攻击者能够利用该漏洞在内核权限下执行任意代码，然而其漏洞代码在2017年就已经存在，直到2024年才被发现并披露~\cite{freebuf-uafvulnerability}。攻击者控制账户恶意投毒时造成的威胁，主要是由于恶意攻击者利用钓鱼攻击，或者账户密码破解，账户重注册接管以及社会工程学等方式采用诱骗，诱导胁迫的手段获取到开发者账户或者代码权限，并往其中投入恶意代码造成攻击，也有原本开发者是良性由于某种特别原因故意投毒，此种攻击方式往往范围较广，且容易发现，较为著名的是2025年知名开发者qix遭受恶意邮件钓鱼，导致其账户下维护的18个超高下载量组件全部遭受恶意混淆代码植入，影响范围极大~\cite{4hou-npm-attack}。开发者滥用AI生成的代码引入的安全风险方面，主要原因是随着LLM代码技术的发展，开发者开始使用AI来生成代码加速开发，然而由于AI的幻觉或者其训练预料中本身存在的BUG，导致其产生的代码被开发者使用而引入威胁。CodeRabbit 在2025年发布的报告显示，其分析的470个开源项目中，320个由AI参与编写，然后安全漏洞增加了2.74倍，并且大部分漏洞是由硬编码密码、不安全的对象引用导致的低级错误~\cite{coderabbit-ai-report}。

对于此类威胁的防护，企业往往采用代码审查，代码仓库的安全配置和完整性校验等方式进行防护。代码审查指的是在软件开发的全流程中通过威胁建模，代码审计等方式对编写的代码进行安全检查，比如在编码阶段和代码提交阶段采用静态分析工具或者动态FUZZ工具进行漏洞检测，或者通过人工的方式对引入的组件和第三方代码片段进行来源审查，安全评估等。代码仓库安全配置用以防护攻击者的恶意投毒，旨在启用多重验证（MFA）等方式，并且对软件实行依赖来源验证和校验和来防止自身软件被恶意篡改。而对于AI生成不安全的代码引入的风险，采用的方式往往也是代码审查，将AI生成的代码视为初级开发者代码，并对其进行加强审计，同时对AI生成的命令行等命令进行核实，此外还应进制关键的安全逻辑代码交由AI来生成，明确使用AI代码的范围和边界。

\textbf{基础设施威胁与防护。}
AI系统的软件应用层来自于基础设施威胁的主要有两方面：