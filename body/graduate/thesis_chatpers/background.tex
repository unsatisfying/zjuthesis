\chapter{AI 系统供应链背景知识}

随着 AI 技术的大力发展，其被应用在现代社会的多个关键领域，并成为当前时代下的核心生产力。在这一过程中， AI 系统也由原本的单一推理模型，轻量级数据和简单应用交互的特点演进为由软件应用、模型框架、硬件加速平台等多层组件共同构成的复杂系统。在这一结构下，AI 系统的开发、训练、部署与运行高度依赖第三方代码库、预训练模型、运行时框架以及异构硬件与驱动程序，逐步形成了一条跨越多个技术层级与信任边界的 AI 系统供应链。相比于传统软件供应链，AI 系统的供应链结构更加复杂，也引入了大量的新型攻击面。本章首先对 AI 系统供应链的整体架构进行梳理，从软件应用层、模型框架层以及硬件加速层三个关键层级出发，介绍各个层级的供应链基本组成，功能职责以及所面临的威胁，从而为后续章节针对不同层级展开的安全分析与攻击奠定背景基础。

\section{软件应用层背景知识}
在 AI 软件开发过程中，为了显著降低研发成本并加速功能迭代，开发者通常遵循“避免重复造轮子”的工程实践，广泛复用已有的开源代码、第三方组件以及成熟的软件开发工具链。与传统软件相比，AI 软件在数据处理、数值计算与模型推理等方面对功能组件的依赖更为密集，这使得其软件应用层天然构建在一条高度依赖外部资源的供应链之上。

\subsection{软件供应链复杂性}
总体而言，AI 系统的软件应用层供应链主要由两条相互交织的子链路构成：一方面是开源组件自身的开发、演化与分发过程；另一方面是AI 软件在开发、构建与维护过程中对外部代码或组件的引入和复用过程。如图~\ref{fig:AI_software_development} 所示，这两条链路共同构成了 AI 软件应用层的基础生态，并在实际工程实践中紧密联系。

\textbf{开源组件开发过程链路。}
在组件开发阶段，组件开发者通常围绕通用功能或特定需求实现可复用的软件模块，并将其发布至公共的开源组件库中，供其他开发者下载与使用。与此同时，组件开发者自身也往往依赖已有的第三方组件，通过直接引入、二次封装或定制化修改的方式完成新组件的开发。因此，组件开发过程本身同样嵌套在更上游的组件供应链之中。
不同编程语言通常对应不同的组件分发生态。例如，Python 语言主要依赖 PyPI，Java 语言对应 Maven Central，Rust 语言则以 Crates.io 作为官方组件仓库~\cite{pypi-website,maven-central,crates-io}。这些集中式组件库极大地降低了依赖获取与分发成本，使得复杂 AI 功能可以通过少量依赖声明快速集成。然而，与之相伴的是依赖规模和复杂度的持续增长。
对于 C/C++ 等底层语言而言，由于其发展历史较早、应用场景高度多样，整体生态呈现去中心化特征，缺乏统一的官方组件仓库。这类语言通常依赖系统原生库（如 GNU C Library）或厂商提供的专有库（如 NVIDIA CUDA-X 库）~\cite{glibc-website,nvidia-cuda-x-libraries}。近年来，尽管出现了诸如 Conan 等第三方包管理工具，但其应用范围与生态成熟度仍相对有限~\cite{sarkar2025cophi}。这种多样化的分发模式进一步增加了 AI 软件应用层供应链的异构性。

\textbf{AI 软件的开发过程链路。}
在 AI 软件的实际开发过程中，软件开发者通常借助源代码管理工具对项目进行协作开发与持续维护。除通过包管理器引入第三方开源组件外，开发者还可能直接采用源码克隆、代码片段复用等方式，将外部项目中的实现集成至自身代码库中，从而进一步缩短开发周期。这一过程中，版本控制系统与代码托管平台成为软件应用层供应链的关键基础设施。当前，Git 已成为事实上的标准版本控制工具，而 GitHub、GitLab、Gitee 以及企业内部代码托管平台则承担了代码协作、审计与发布的重要角色。在软件开发完成后，构建与打包工具被用于生成可部署的软件形态，例如可执行二进制文件、安装包或容器镜像，并最终交付给终端用户。

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figure/AI软件开发.png}
    \caption{\label{fig:AI_software_development}软件应用层供应链架构图}
\end{figure}

\textbf{依赖解析的复杂性和动态性。}
在上述两条供应链链路的共同作用下，AI 软件应用层逐步形成了结构复杂、层级深度较大的依赖关系网络，通常以依赖图的形式进行刻画。如图~\ref{fig:albumentationsx_dependency_graph} 所示，albumentationsx 软件在 2.0.13 版本中依赖多个第三方组件，并进一步引入多层间接依赖~\cite{albumentationsx-repo}。
%
在一个依赖图中，单个软件包通常对应一个特定版本，但在某些语言生态（如 JavaScript）中，同一依赖图中可能同时存在同一组件的多个版本。每一个软件包既可能作为直接依赖被上层软件显式引入，也可能作为间接依赖隐藏在更深层的依赖链路中。例如，图中 numpy 2.2.6 版本既是 albumentationsx 的直接依赖，同时也是其经由 scipy 1.16.3 引入的间接依赖。
%
此外，AI 软件的依赖图并非静态不变。依赖版本往往通过范围约束进行声明，例如在 albumentationsx 的配置文件 setup.py 中指定的一条依赖为 numpy>=1.24.4~\cite{albumentationsx-setup}。在此情况下，依赖解析工具通常会选择满足约束条件的最新版本。一旦上游组件发布新版本，软件在重新构建或安装时，其依赖图结构便可能随之发生变化，从而引入新的行为差异。

依赖图的动态性也使得依赖解析算法变得极其复杂。以 Python 生态为例，用户通常通过官方包管理器 pip 安装第三方依赖组件~\cite{pip-documentation}。在安装过程中，pip 会解析配置文件中的依赖声明，并从 PyPI 获取候选版本列表，依据版本约束与兼容规则逐步选择合适的版本进行下载与安装。该解析过程会递归地处理新引入的依赖，并在出现冲突时进行回溯与重新选择。
由于该过程采用边解析边安装的策略，依赖规模较大时往往面临解析效率低下、冲突频繁等问题，甚至可能因为依赖地狱或者依赖冲突问题导致整个依赖解析过程失败~\cite{wang2022smartpip,fan2020escaping}。这种高度动态且依赖密集的安装机制，使得 AI 软件应用层在功能灵活性提升的同时，也不可避免地引入了更复杂的且难以全面发现的供应链安全风险。

\begin{figure}[t]
    \centering
    \includegraphics[width=0.85\linewidth]{figure/依赖图.png}
    \caption{\label{fig:albumentationsx_dependency_graph} albumentationsx 软件 2.0.13版本依赖图}
\end{figure}

\subsection{软件供应链对AI系统的威胁与防护}
由于软件供应链普遍存在的无条件信任机制，加之依赖解析过程的复杂性与动态性，AI 系统在应用层面临着多维度的安全威胁。从 AI 软件生命周期视角来看，主要分为四个大类，代码来源威胁，基础设施威胁，软件运行时威胁和依赖传播威胁。

\textbf{代码来源威胁与防护。}
代码来源威胁主要源于三个维度：一是组件或软件开发人员编写代码时因疏忽引入的逻辑缺陷或者安全漏洞；二是攻击者通过劫持开发者账户或者非法获取仓库权限实施的恶意投毒；三是开发者滥用大语言模型生成的代码而引入的衍生风险。在开发者编写代码阶段，漏洞通常源于开发者编码时的错误，或者是通过代码克隆将别人包含漏洞的代码无意地引入到开发代码中的缺陷，此类漏洞往往具有极强的隐蔽性和较长的潜伏周期。例如潜伏于 Linux 内核 TCP 系统中的高危漏洞 CVE-2024-36904，允许攻击者利用该漏洞获得在内核权限下执行任意代码的能力，尽管该缺陷在2017年就已经存在，但直到2024年才被发现并披露，在此期间，任何依赖受影响内核版本的系统均暴露于潜在攻击风险之中~\cite{freebuf-uafvulnerability}。在攻击者控制账户恶意投毒方面，恶意攻击者常利用钓鱼攻击、账户密码破解、账户重注册接管以及社会工程学等手段获取到开发者账户或者代码提交权限，并直接向上游项目植入恶意逻辑，此种攻击方式往往范围较广，且容易发现。较为著名的是 2025 年知名开发者 qix 遭受恶意邮件钓鱼，导致其账户下维护的 18 个超高下载量组件全部遭受恶意混淆代码植入，影响范围极大~\cite{4hou-npm-attack}。也有原本开发者是良性由于某种特别原因投毒，比如node-ipc开发者因为俄乌战争反俄故意投毒事件~\cite{nsfocus_nodeipc_2022}。此外，随着 LLM 在软件开发中的普及，AI 幻觉及训练语料中既有的缺陷导致生成的代码可能携带安全隐患。CodeRabbit 2025 年的报告指出，在其分析的开源项目中，由 AI 参与编写的项目比例极高，而由此引入的硬编码凭证、不安全对象引用等漏洞导致安全风险增加了 2.74 倍~\cite{coderabbit-ai-report}。

对于此类威胁的防护，企业往往采用代码审查，代码仓库的安全配置和完整性校验等方式进行防护。代码审查指的是在软件开发的全流程中通过威胁建模，代码审计等方式对编写的代码进行安全检查，比如在编码阶段和代码提交阶段采用静态分析工具或者动态模糊测试工具进行漏洞检测，或者通过人工的方式对引入的组件和第三方代码片段进行来源审查，安全评估等。代码仓库安全配置用以防护攻击者的恶意投毒，旨在启用多重验证(Multi Factor Authentication,MFA)等方式，并且对软件实行依赖来源验证和校验和来防止自身软件被恶意篡改。而对于AI生成不安全的代码引入的风险，采用的方式往往也是代码审查，将AI生成的代码视为初级开发者代码，并对其进行加强审计，同时对AI生成的命令行等命令进行核实，此外还应禁止关键的安全逻辑代码交由AI来生成，明确使用AI代码的范围和边界。

\textbf{基础设施威胁与防护。}
AI系统的软件应用层来自于基础设施威胁的主要有两方面：一个是利用持续集成和持续部署的管道(continuous integration and continuous deployment, CI/CD)构造的威胁，一个是利用编译器或者编译平台构造的威胁。攻击者可以利用CI/CD管道中集成的工具链投毒的方式使得攻击者使用和运行这些工具时执行恶意代码，或者在CI/CD部署脚本中嵌入恶意逻辑，或者是脚本编写者自身不注意写入的错误逻辑，使得构建平台能够运行这些脚本中的恶意逻辑，此外，更为严重的是，这些脚本中还可能包含一些密钥在内的敏感信息，容易被人窃取。例如CVE-2020-14188表明，Atlassian 在 GitHub 上提供了 atlassian/gajira-create脚本，以帮助开发者从不同用户处跟踪问题报告，然而不幸的是，该脚本在处理插值的属性数据时，额外引入了一个模板引擎，从而导致了一个可由用户输入控制的任意代码执行漏洞~\cite{pan2023ambush, CVE-2020-14188}。在利用编译器和编译平台方面，攻击者可以利用恶意篡改的编译器，例如2015年著名的xcodeGhost事件，攻击者利用国内下载Xcode速度慢的特点，在网盘上传了下载好的xcode供人下载，但是该版本的安装包被人嵌入了恶意xcodeGhost框架，使得使用该编译器编译出的app会自动执行非开发者预期的功能，包括唤起电话，发短信等~\cite{gui2016analysis}。攻击者还可以通过构建平台的恶意代码注入进行攻击，较为著名的是2020年Solarwinds攻击，攻击者未经授权访问了 SolarWinds 的构建平台，该平台用于编译和打包 SolarWinds Orion 软件。此脚本将恶意代码注入编译后的 SolarWinds Orion 软件中。当用户安装受感染的软件时，恶意代码会在他们的系统上执行，从而使攻击者能够未经授权访问他们的系统。攻击者还能够从他们的系统中窃取敏感数据，例如凭证、知识产权和客户信息~\cite{tran2021solarwinds}。

防御此类攻击的方式主要是使用可信来源的构建系统或者构建工具， 并且将CI/CD的基础设施，包括脚本和工具也加入安全边界，作为审查内容的一环。此外对于入侵构建系统方面，往往采用最小权限原则限制构建系统的访问权限，并且为不同的构建服务设置不同的构建虚拟环境，将他们进行隔离。最后，采用不同的安全扫描工具来防止脚本的隐私泄露也是一个较为不错的方法。

\textbf{软件运行时威胁与防护。}
软件运行时威胁和代码来源威胁较为相似，但是软件运行时威胁更侧重于一个动态的过程，其包括来自于运行环境的威胁和错误配置的威胁。来自于运行环境的威胁来源于两方面，一方面，由于依赖解析或者依赖声明的错误，可能会导致软件在构建编译时引入包含漏洞的组件版本或者人为恶意投毒的版本，从而在运行阶段触发安全问题，这种情况最典型的攻击为依赖混淆攻击，即攻击者向公用开源软件仓库（如npm， PyPI， Maven等）上传一个名称和一些企业内部私有软件依赖包名字相同的，且软件包版本号更高的恶意公共包，当公司内部构件项目时，依赖解析工具（如npm， pip， mvn等）就会错误的使用版本号更高的远程恶意软件包而非企业内部的私有包，从而导致企业内部遭遇攻击~\cite{ding2024security}。另一方面，AI软件通常运行于容器，云环境或者虚拟机中，若底层操作系统或者容器配置存在漏洞，攻击者便可以利用这来达到提权的目的，例如，如果云环境中的宿主机的内核版本中存在Dirty Pipe漏洞（CVE-2022-0847），恶意的AI程序就可以利用管道机制的缺陷和多个AI服务通常共享一个宿主机的机制，覆盖宿主机内核页的缓存，并向主机的只读文件中写入任意内容~\cite{tanwar2022study}。而来自于错误配置的威胁往往是由于容器的配置错误或者AI软件的一些配置错误导致的攻击，以大模型运行框架Ollama为例，其在默认配置中并未包含身份验证配置，并且其服务监听的默认地址为0.0.0.0，这导致其Ollama服务会直接暴露在公网之上，使得攻击者可以直接访问推理接口，甚至触发路径遍历漏洞，进而窃取私有模型权重~\cite{cnvd_2025_04094,nvd_cve_2024_37032}。

针对AI软件运行时的防护有效手段较少，针对类似依赖混淆攻击的威胁，现有防护主要依赖于版本锁定，或者采用DevOps等软件供应链管理服务来帮助扫描来自于公共库的威胁。而针对容器，云环境所带的漏洞或者错误配置导致的威胁，往往只能依靠及时补丁以及不安全配置的清理来解决，或者采用容器的权限检测和验证工具等方式。

\textbf{依赖传播威胁与防护。}
依赖传播威胁关注的是复杂的软件供应链由于依赖关系网的庞大，一个组件遭受风险会使其风险扩散，最终导致整个依赖关系网都遭受风险，这种威胁覆盖面广，隐蔽性强，且较难检测。例如2021年的Log4shell漏洞，由于Java生态中Log4j2和log4j组件存在漏洞，导致依赖该组件作为基础日志框架的数以万计的下游软件均受到影响~\cite{cve_2021_44228}。此外，依赖传播往往是隐式的，这是因为AI软件往往只在配置文件中声明直接依赖，而不声明依赖的依赖（间接依赖），这导致即使未引用下游开发者的代码，仍然可能在没有感知的情况下遭受风险。

防护这种依赖传播威胁往往从依赖的可见性和完整性触发，例如可以通过物料清单（Software Bill of Materials, SBOM）和依赖图分析技术来全面刻画软件所直接和间接依赖的软件，而对于已知物料是否存在漏洞需要借助持续监测工具和漏洞扫描工具进行所有组件的扫描，评估高风险节点，并定期打补丁。如果确定某个组件存在漏洞，则还需要通过可达性分析来判断漏洞是否可触发，是否会对AI软件产生影响。